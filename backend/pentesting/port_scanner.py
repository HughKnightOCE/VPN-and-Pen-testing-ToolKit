"""
Port Scanner
Scans hosts for open ports using socket-based approach
"""
import socket
import logging
from typing import Dict, List
import threading

logger = logging.getLogger(__name__)


class PortScanner:
    """Scans for open ports using socket connections"""
    
    # Common service ports and their names
    COMMON_SERVICES = {
        21: 'FTP',
        22: 'SSH',
        23: 'Telnet',
        25: 'SMTP',
        53: 'DNS',
        80: 'HTTP',
        110: 'POP3',
        143: 'IMAP',
        443: 'HTTPS',
        445: 'SMB',
        3306: 'MySQL',
        3389: 'RDP',
        5432: 'PostgreSQL',
        5900: 'VNC',
        8080: 'HTTP-Proxy',
        8443: 'HTTPS-Alt',
    }
    
    def __init__(self):
        self.results = {}
    
    def scan(self, host: str, ports: str = '1-1000') -> Dict:
        """Scan host for open ports"""
        try:
            logger.info(f"Scanning {host} for ports {ports}")
            
            port_list = self._parse_port_range(ports)
            open_ports = []
            closed_ports = []
            services = {}
            
            # Resolve hostname
            try:
                ip = socket.gethostbyname(host)
                logger.info(f"Resolved {host} to {ip}")
            except socket.gaierror:
                return {
                    'host': host,
                    'error': f'Could not resolve hostname {host}',
                    'open_ports': [],
                    'closed_ports': [],
                    'services': {},
                    'scan_type': 'failed'
                }
            
            # Scan ports
            for port in port_list:
                if self._is_port_open(ip, port, timeout=1):
                    open_ports.append(port)
                    service_name = self.COMMON_SERVICES.get(port, 'Unknown')
                    services[port] = {
                        'name': service_name,
                        'state': 'open'
                    }
                    logger.info(f"Port {port} open on {host}")
                else:
                    closed_ports.append(port)
            
            logger.info(f"Scan complete: {len(open_ports)} open ports found")
            
            return {
                'host': host,
                'open_ports': open_ports,
                'closed_ports': closed_ports[:10],  # Limit closed ports
                'services': services,
                'scan_type': 'basic'
            }
        
        except Exception as e:
            logger.error(f"Port scan failed: {e}")
            return {
                'host': host,
                'error': str(e),
                'open_ports': [],
                'closed_ports': [],
                'services': {},
                'scan_type': 'failed'
            }
    
    def _is_port_open(self, host: str, port: int, timeout: int = 1) -> bool:
        """Check if a port is open"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(timeout)
            result = sock.connect_ex((host, port))
            sock.close()
            return result == 0
        except Exception as e:
            logger.debug(f"Error checking port {port}: {e}")
            return False
    
    @staticmethod
    def _parse_port_range(ports: str) -> List[int]:
        """Parse port range string (e.g., '1-1000', '22,80,443')"""
        port_list = []
        
        try:
            for part in ports.split(','):
                part = part.strip()
                if '-' in part:
                    start, end = part.split('-')
                    port_list.extend(range(int(start), int(end) + 1))
                else:
                    port_list.append(int(part))
        except Exception as e:
            logger.error(f"Error parsing ports: {e}")
            port_list = list(range(1, 1001))  # Default to 1-1000
        
        return port_list
