"""
Certificate Analyzer
Analyzes SSL/TLS certificates
"""
import ssl
import socket
import logging
from datetime import datetime
from typing import Dict
from cryptography import x509
from cryptography.hazmat.backends import default_backend

logger = logging.getLogger(__name__)


class CertificateAnalyzer:
    """Analyzes SSL/TLS certificates"""
    
    def __init__(self):
        self.backend = default_backend()
    
    def analyze(self, host: str, port: int = 443) -> Dict:
        """Analyze SSL/TLS certificate for a host"""
        try:
            logger.info(f"Analyzing certificate for {host}:{port}")
            
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Get certificate
            with socket.create_connection((host, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert_der = ssock.getpeercert(binary_form=True)
                    cert = x509.load_der_x509_certificate(cert_der, self.backend)
            
            # Extract certificate information
            cert_info = self._extract_cert_info(cert)
            
            # Check for vulnerabilities
            vulnerabilities = self._check_vulnerabilities(cert_info)
            
            return {
                'host': host,
                'port': port,
                'certificate': cert_info,
                'vulnerabilities': vulnerabilities,
                'secure': len(vulnerabilities) == 0
            }
        
        except Exception as e:
            logger.error(f"Certificate analysis failed: {e}")
            return {
                'host': host,
                'port': port,
                'error': str(e),
                'certificate': {},
                'vulnerabilities': [],
                'secure': False
            }
    
    def _extract_cert_info(self, cert: x509.Certificate) -> Dict:
        """Extract information from certificate"""
        try:
            subject = cert.subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)
            subject_cn = subject[0].value if subject else 'Unknown'
            
            issuer = cert.issuer.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)
            issuer_cn = issuer[0].value if issuer else 'Unknown'
            
            san_ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
            san_names = [name.value for name in san_ext.value]
            
            return {
                'subject': str(subject_cn),
                'issuer': str(issuer_cn),
                'valid_from': cert.not_valid_before.isoformat(),
                'valid_until': cert.not_valid_after.isoformat(),
                'san': san_names,
                'serial': str(cert.serial_number),
                'version': cert.version.name,
                'signature_algo': cert.signature_algorithm_oid._name
            }
        except Exception as e:
            logger.error(f"Error extracting cert info: {e}")
            return {}
    
    def _check_vulnerabilities(self, cert_info: Dict) -> list:
        """Check for common certificate vulnerabilities"""
        vulnerabilities = []
        
        try:
            if not cert_info:
                return vulnerabilities
            
            # Check expiration
            valid_until = datetime.fromisoformat(cert_info['valid_until'])
            if valid_until < datetime.now():
                vulnerabilities.append('Certificate expired')
            elif (valid_until - datetime.now()).days < 30:
                vulnerabilities.append('Certificate expires soon')
            
            # Check weak signature algorithm
            weak_algos = ['md5', 'sha1']
            sig_algo = cert_info.get('signature_algo', '').lower()
            if any(weak in sig_algo for weak in weak_algos):
                vulnerabilities.append(f'Weak signature algorithm: {sig_algo}')
            
            # Check self-signed
            subject = cert_info.get('subject', '')
            issuer = cert_info.get('issuer', '')
            if subject == issuer:
                vulnerabilities.append('Self-signed certificate')
        
        except Exception as e:
            logger.error(f"Error checking vulnerabilities: {e}")
        
        return vulnerabilities
